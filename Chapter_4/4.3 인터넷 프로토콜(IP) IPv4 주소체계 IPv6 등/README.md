# 4.3 인터넷 프로토콜(IP): IPv4, 주소체계, IPv6 등

## 4.3.1 IPv4 데이터그램 포맷

인터넷 네트워크 계층 패킷을 데이터그램(datagram)이라고 부른다.

### IPv4 데이터그램 포맷

<p align="center"><img width="500" alt="데이터그램" src="https://user-images.githubusercontent.com/76640167/212647972-acc5a773-a64c-4cd9-adb8-13f3f02876b9.png">

- `버전 번호`
    - 4비트로 데이터그램의 IP 프로토콜 버전을 명시한다.
    - 라우터는 버전 번호를 확인하여 데이터그램의 나머지 부분을 어떻게 해석할지 결정한다.
    - 다른 버전의 IP는 다른 데이터그램 포맷을 사용한다.
- `헤더 길이`
    - IPv4 데이터그램은 헤더에 가변 길이의 옵션을 포함하므로 이 네 비트로 IP 데이터그램에서 실제 페이로드가 시작하는 곳을 결정한다.
    - 대부분의 IPv4는 옵션을 포함하지 않으므로 대체로 IPv4 데이터그램 헤더는 20바이트다.
- `서비스 타입`
    - IPv4 헤더에 포함된 서비스 타입 비트는 각기 다른 유형의 IP 데이터그램을 구별한다. 예를 들어, 실시간 데이터그램과 비실시간 트래픽을 구분하는 데 유용하다.
- `데이터그램 길이`
    - 바이트로 계산한 IP 데이터그램의 전체 길이다. 총 16비트를 차지하므로 IP 데이터그램의 최대 길이는 65,535 바이트이지만 1,500보다 큰 경우는 거의 없다.
- `식별자`, `플래그`, `단편화 오프셋`
    - IP 단편화와 관련이 있는 필드들이다.
    - 큰 IP 데이터그램이 여러 개의 작은 IP 데이터그램으로 분할된 다음 목적지로 독립적으로 전달되며, 여기서 페이로드 데이터가 최종 호스트의 트랜스포트 계층으로 전달되기 전에 다시 모인다.
- `TTL(time to live)`
    - 이 필드는 네트워크에서 데이터그램이 무한히 순환하지 않도록 한다(라우팅 루프). 라우터가 데이터그램을 처리할 때마다 감소하고, 이 필드가 0이 되면 데이터그램을 폐기한다.
- `프로토콜`
    - 이 필드는 일반적으로 IP 데이터그램이 최종목적지에 도착했을 때만 사용된다. 이 필드값은 IP 데이터그램에서 데이터 부분이 전달될 목적지의 트랜스포트 계층의 특정 프로토콜(TCP, UDP)을 명시한다.
    - IP 데이터그램에서 이 필드는 트랜스포트 계층에서 포트 번호 필드와 역할이 유사하다.
- `헤더 체크섬`
    - 헤더 체크섬은 라우터가 수신한 IP 데이터그램의 비트 오류를 탐지하는데 도움을 준다.
    - 라우터는 오류 검출된 데이터그램을 폐기한다.
    - TTL 필드와 옵션 필드의 값은 변경되므로 체크섬은 각 라우터에서 재계산되고 저장되어야 한다.
    - 트랜스 포트 계층과 네트워크 계층에서 오류 검사를 수행하는 이유
        - IP 헤더만 IP 계층에서 체크섬을 수행하지만 TCP/UDP 체크섬은 전체 TCP/UDP 세그먼트를 계산한다.
        - TCP/UDP와 IP는 동일한 프로토콜 스택에 속할 필요가 없다. 원리상 TCP는 IP가 아닌 곳 위에서도 운영될 수 있다.
- `출발지와 목적지 IP 주소`
    - 출발지가 데이터그램을 생성할 때, 자신의 IP 주소를 출발지 IP 주소 필드에 삽입하고 목적지 IP 주소를 목적지 IP 주소 필드에 삽입한다.
- `옵션`
    - IP 헤더 필드를 확장한다.
    - 모든 데이터그램 헤더 옵션 필드에 정보를 포함하지 않는 방법으로 오버헤드를 해결하기 위해 헤더 옵션은 거의 사용되지 않는다.
    - 데이터그램 헤더가 가변 길이로 데이터 필드 시작점을 초기에 결정할 수 없어 문제를 복잡하게 만든다.
- `데이터(페이로드)`
    - 데이터그램이 존재하는 이유이자 가장 중요한 마지막 필드이다. 대부분의 경우 목적지에 전달하기 위해 트랜스포트 계층 세그먼트를 포함한다.

대부분의 IP 데이터그램은 총 20바이트(옵션은 없다고 가정)의 헤더를 갖는다.

TCP 세그먼트를 전송한다면 단편화가 되지 않은 각 데이터그램은 애플리케이션 계층의 메시지와 더불어 총 40바이트의 헤더(IP 헤더 20, TCP 헤더 20)을 전송한다.

<br/>

## 4.3.2 IPv4 주소체계

호스트는 일반적으로 네트워크와 연결되는 하나의 링크를 갖는다.

호스트 IP가 데이터그램을 보낼 때 이 링크를 통해 데이터링크를 보낸다.

호스트와 물리적 링크 사이의 경계를 `인터페이스(interface)`라고 부른다.

라우터는 여러 개의 링크와 연결되고, 링크와 라우터 사이도 `인터페이스(interface)`로 이루어져있어 여러개의 `인터페이스(interface)`를 갖는다.

모든 호스트와 라우터는 IP 데이터그램을 송수신할 수 있으므로 IP는 각 호스트와 라우터 인터페이스가 IP 주소를 갖도록 요구한다.

이러한 각 인터페이스는 고유한 IP 주소를 갖는다.

따라서 **기술 면에서 IP 주소는 `인터페이스(interface)`를 포함하는 호스트 라우터보다는 `인터페이스(interface)`와 관련이 있다.**

<br/>

### 서브넷과 IP 주소

각 IP 주소는 **32비트 길이**다. 따라서 2^32개의 주소를 사용할 수 있다. 일반적으로 **주소의 각 바이트를 십진수로 표현하고 주소의 다른 바이트와 점으로 구분하는 십진 표기법**을 사용한다.

인터페이스의 IP는 마음대로 선택할 수 없다. IP 주소의 일부는 연결된 `서브넷`이 결정한다.

<p align="center"><img width="500" alt="서브넷" src="https://user-images.githubusercontent.com/76640167/212662555-482eb213-def6-4066-b4ca-2b7e65714196.png">

왼쪽 3개의 호스트와 라우터 인터페이스는 모두 223.1.1.xxx 형식의 IP 주소를 갖는다. 또, 4개의 인터페이스가 중계하는 **라우터 없이** 하나의 네트워크에 서로 연결되어 있다.

이 네트워크는 이더넷 LAN으로 상호연결되고 이 경우 인터페이스는 이더넷 허브나 이더넷 스위치 또는 무선 AP로 상호연결된다.

IP 용어로 세 호스트 들의 인터페이스들과 하나의 라우터 인터페이스로 연결된 네트워크는 `서브넷(subnet)`을 구성한다고 말한다.

IP 주소체계는 이 서브넷에 `223.1.1.0/24` 라는 주소를 할당하는데 여기서 `/24`는 서브넷 마스크라 부르는데, 왼쪽 24비트가 서브넷 주소라는 것을 가리킨다.

위 그림에서는 3개의 서브넷을 볼 수 있다.

<br/>

<p align="center"><img width="500" alt="6개의 서브넷" src="https://user-images.githubusercontent.com/76640167/212667479-eb056442-26a3-4e8f-8bf7-97a1e864981a.png">

서브넷 IP의 정의는 여러 호스트를 라우터 인터페이스에 연결하는 이더넷 세그먼트만을 의미하는 것은 아니다.

위 그림을 보면 3개의 라우터도 점대점으로 연결되어있는 것을 볼 수 있다.

여기서는 호스트와 라우터의 연결 뿐만 아니라 라우터 간의 연결에서도 서브넷을 볼 수 있다.

총 6개의 서브넷을 찾을 수 있다.

<br/>

**서브넷의 정의**

> 💡서브넷을 결정하려면 먼저 호스트나 라우터에서 각 인터페이스를 분리하고 고립된 네트워크를 만든다. 이 고립된 네트워크의 종단점은 인터페이스의 끝이 된다. 이렇게 고립된 네트워크 각각을 서브넷이라고 부른다.

위에 의하면 다수의 이더넷 세그먼트와 종단 간의 링크를 갖는 기관은 한 서브넷에서 모든 장비가 같은 서브넷 주소를 갖는 그런 서브넷을 여러개 가질 수 있다.

서로 다른 서브넷은 다른 주소를 가져야 하지만 실제로 서브넷 주소는 같은 부분이 많다.

<br/>

### CIDR

인터넷 주소 할당 방식 중 하나다.

CIDR는 서브넷 주소 체계 표기를 일반화하고 있다.

a.b.c.d/x 형식 주소에서 최상위 비트(Most significant bit)를 의미하는 x는 IP 주소의 네트워크 부분을 구성한다.

이를 해당 주소의 `프리픽스` 또는 `네트워크 프리픽스`라고 부른다.

한 기관은 통상 연속적인 주소의 블록(공통 프리픽스를 갖는 주소 범위)을 할당 받고 기관 장비들의 IP 주소는 공통 프리픽스를 공유한다.

외부 기관의 라우터는 목적지 주소가 내부 기관인 데이터그램을 전달할 때, 단지 앞의 x 비트들만 고려한다.

a.b.c.d/x 형태의 한 엔트리만으로 기관 목적지로 패킷을 전달하는 데 충분하므로, 이런 라우터들에서 포워딩 테이블의 크기를 상당히 줄여준다.

주소의 나머지 32-x 비트들은 기관 내부에 같은 네트워크 프리픽스를 갖는 모든 장비를 구별한다.

이 비트들은 기관 내부의 라우터에서 패킷을 전달할 때 사용되며 이 하위 비트들은 추가적으로 서브넷 구조를 가질 수도 있다.

<br/>

### 클래스 주소체계

CIDR가 채택되기 전에는 IP 주소의 네트워크 부분을 8, 16, 24 비트로 제한했고 각각의 비트를 서브넷 주소로 갖는 서브넷을 각각 A, B, C 클래스 네트워크로 분류했기 때문에 이러한
주소체계는 `클래스 주소체계`라고 알려졌다.

그러나 서브넷 부분이 정확히 1, 2, 3 바이트여야 하는 요구사항은 중소형 크기의 네트워크로 급속히 증가하는 기관의 수를 지원하기엔 문제가 있었다.

예를 들어 클래스(/24) 서브넷은 254개의 호스트만을 제공하므로 많은 조직을 위해서는 턱없이 부족하고, 클래스(/16) 서브넷은 65634개의 호스트를 제공하여 너무 크다.

<br/>

### 브로드캐스트 주소

IP의 또 다른 형태인 브로드캐스트 주소 255.255.255.255가 있다.

호스트가 목적지 주소가 255.255.255.255인 데이터그램을 보내면, 이 메시지는 같은 서브넷에 있는 모든 호스트에게 전달된다.

<br/>

다음으로는 한 기관에서 그들의 장비를 위한 주소 블록을 어떻게 획득하는지 알아본 후에, 이 획득한 주소 블록의 주소를 어떻게 장비에 할당하는지 살펴보겠다.

<br/>

### 주소 블록 획득

기관의 서브넷에서 사용하기 위한 IP 주소 블록을 얻기 위해, 네트워크 관리자는 먼저 이미 할당받은 주소의 큰 블록에서 주소를 제공하는 ISP와 접촉해야 한다.

<p align="center"><img width="500" alt="IP 주소 블록" src="https://user-images.githubusercontent.com/76640167/212675085-61430550-15e6-4fb9-a909-1a7bb8bac116.png">

ISP가 위와 같은 블럭을 할당 받았다고 할 때, ISP는 블록을 다음처럼 같은 크기의 작은 주소 블록 8개로 나누고, 이것으로 8개 조직을 지원할 수 있다.

ISP는 비영리 단체인 `ICANN`으로 부터 주소 블록을 할당 받는다.

`ICANN`의 역할은 **IP 주소 할당**과 **DNS 루트 서버 관리**다.

<br/>

### 호스트 주소 획득: 동적 호스트 구성 프로토콜 (DHCP)

한 기관은 ISP로부터 주소 블록을 획득하여, 개별 IP 주소를 기관 내부의 호스트와 라우터 인터페이스에 할당한다.

라우터 인터페이스 주소에 대해, 시스템 관리자는 라우터 안에 IP 주소를 할당한다.

호스트에 IP 주소를 할당하는 것은 수동으로 구성이 가능하지만 일반적으로 `동적 호스트 구성 프로토콜(DHCP)`을 많이 사용한다.

DHCP는 호스트가 IP 주소를 자동으로 얻을 수 있게 하고, 서브넷 마스크, 첫 번째 홉 라우터 주소나 로컬 DNS 서버 주소 같은 추가 정보를 얻게 해준다.

DHCP는 자동으로 호스트와 연결해주는 능력 때문에 플러그 앤 플레이 프로토콜 또는 제로 구성 프로토콜이라고도 한다.

<br/>

<p align="center"><img width="500" alt="DHCP 클라이언트와 서버" src="https://user-images.githubusercontent.com/76640167/212679674-19caa44a-265c-43c1-84a6-ecdcdbcaec8e.png">

DHCP는 클라이언트-서버 프로토콜이다.

클라이언트는 일반적으로 IP 주소를 포함하며 네트워크 설정을 위한 정보를 얻고자 새롭게 도착한 호스트다.

각 서브넷은 DHCP 서버를 갖거나 없다면 해당 네트워크에 대한 DHCP 서버 주소를 알려줄 DHCP 연결 에이전트(일반적으로 라우터)가 필요하다.

<br/>

<p align="center"><img width="400" alt="DHCP 동작" src="https://user-images.githubusercontent.com/76640167/212680264-a3e3a046-d66c-46d3-b09f-2961a5717062.png">

위 그림은 새로운 호스트가 도착할 경우, DHCP 프로토콜의 4단계 과정을 보여준다.

- `DHCP 서버 발견`
    - 먼저 새롭게 도착한 호스트는 상호작용할 DHCP를 발견한다. 이것은 **DHCP 발견 메시지**를 사용하여 수행되며, 클라이언트는 포트 67번으로 UDP 패킷을 보낸다.
    - DHCP 클라이언트는 **DHCP 발견 메시지**를 포함하는 IP 데이터 그램을 생성하는데, 이 메시지 내의 목적지 IP 주소를 브로드캐스트 IP 주소 255.255.255.255로 설정하고 출발지 IP
      주소는 0.0.0.0으로 설정한다.
    - 링크 계층으로 IP 데이터그램을 보내며 이 프레임은 서브넷에 연결된 모든 노드로 브로드캐스트된다.
- `DHCP 서버 제공`
    - DHCP 발견 메시지를 받은 DHCP 서버는 DHCP 제공 메시지를 클라이언트로 응답한다.
    - 이때에도 IP 브로드캐스트 주소를 사용하여 서브넷의 모든 노드로 이 메시지를 브로드캐스트한다.
    - 서브넷에는 여러 DHCP 서버가 존재하기 때문에, 클라이언트는 여러 DHCP 제공 메시지로부터 가장 최적의 위치에 있는 DHCP 서버를 선택한다.
    - 각각의 서버 제공 메시지는 수신된 발견 메시지의 트랜잭션 ID, 클라이언트에 제공된 IP 주소, 네트워크 마스크, **IP 주소 임대 기간**을 포함한다.
- `DHCP 요청`
    - 새롭게 도착한 클라이언트는 하나 또는 그 이상의 서버 제공자 중에서 선택할 것이고 선택된 제공자에게 파라미터 설정으로 되돌아오는 **DHCP 요청 메시지**로 응답한다.
- `DHCP ACK`
    - 서버는 DHCP 요청 메시지에 대해 요청된 파라미터를 확인하는 **DHCP ACK 메시지**로 응답한다.

클라이언트가 DHCP ACK을 받으면 상호작용이 종료되고 클라이언트는 임대 기간동안 할당 IP 주소를 사용할 수 있다.

<br/>

DHCP는 노드가 새로운 서브넷에 연결하고자 할 때마다 새로운 IP 주소를 DHCP로부터 얻기 때문에, 이동 노드가 서브넷 사이를 이동할 때 원격 애플리케이션에 대한 TCP 연결이 유지될 수 없다는 결점이 있다.

<br/>

## 4.3.3 네트워크 주소 변환 (NAT)

모든 호스트가 서브넷으로부터 IP를 할당받고 할 때 네트워크가 현저하게 커지면 큰 주소 블록이 할당되어야 한다.

ISP가 이미 해당 주소 범위의 인접한 부분을 할당해버리는 등의 문제가 발생할 수 있는데 이런 경우에는 `네트워크 주소 변환(NAT)`으로 주소를 할당할 수 있다.

<p align="center"><img width="700" alt="NAT" src="https://user-images.githubusercontent.com/76640167/212688870-ba4c2f2c-522f-438d-9eb3-3a518e76a7a9.png">

**NAT 가능 라우터**는 위 그림의 오른쪽처럼 홈 네트워크의 일부인 인터페이스를 갖는다.

홈 네트워크의 4개 인터페이스 모두 같은 네트워크 주소 `10.0.0.0/24`를 갖는다.

주소 공간 `10.0.0.0/8`은 `사설망` 또는 그림의 홈 네트워크와 같은 `사설 개인 주소를 갖는 권역(realm)`을 위해 RFC에 예약된 IP 주소 공간 세 부분 중의 하나다.

> 💡 사설 개인 주소를 갖는 권역(realm)이란 네트워크 주소들이 그 네트워크 내부에 있는 장비에게만 의미가 있는 그런 네트워크를 의미한다.

사설 개인 주소를 갖는 권역은 홈 네트워크 내부에서만 의미가 있다. 즉, 글로벌 인터넷과는 송수신할 수 없다.

<br/>

NAT 가능 라우터는 외부 세계로는 **하나의 IP 주소를 갖는 하나의 장비**로 동작한다.

그림을 보면 홈 라우터를 떠나 인터넷으로 가는 트래픽의 출발지 IP 주소는 `138.76.29.7` 즉, **라우터의 출력 라우터 인터페이스의 IP 주소**를 갖는다.

홈으로 들어오는 트래픽의 목적지 주소는 마찬가지로 `138.76.29.7`을 가져야한다.

본질적으로 NAT 가능 라우터는 외부에서 들어오는 홈 네트워크의 상세한 사항을 숨긴다.

<br/>

WAN에서 같은 목적지 IP 주소를 갖는 NAT 라우터에 모든 데이터 그램이 도착하면, 라우터가 주어진 데이터그램을 전달하는 내부 호스트를 어떻게 알 수 있을까?

NAT 라우터에서 `NAT 변환 테이블`을 사용하고, 그 테이블에 IP 주소와 포트 번호를 포함하여 알 수 있다.

위 그림의 **NAT 변환 테이블**을 보며 순서대로 잘 따라가보길 바란다.

웹 서버는 내부 호스트를 모른채 WAN side의 라우터를 목적지 IP로 하여 응답하고, 라우터는 이 응답을 NAT 변환 테이블을 사용하여 알맞은 내부 호스트에 전달한다.

<br/>

포트 번호는 호스트 주소 지정이 아닌 프로세스 주소 지정에 사용된다.

서버 프로세스는 잘 알려진 포트 번호에서 요청이 올 때까지 기다리고 P2P 프로토콜의 피어는 서버로서의 역할을 할 때 들어오는 연결을 수락해야 하기 때문에 홈 네트워크에서 실행되는 서버에 문제가 발생할 수 있다.

이 문제의 기술적인 해결책으로는 NAT 순회 도구가 있다.

<br/>

## 4.3.4 IPv6

IPv4 주소 공간이 빠르게 고갈되어가면서 IPv6 주소 체계가 개발되었다.

<br/>

### IPv6 데이터그램 포맷

IPv6 중요한 변화

- 확장된 주소 기능
    - IPv6는 IP 주소 크기를 32비트에서 128비트로 확장했으므로 IP 주소가 고갈되는 일은 발생하지 않을 것이다.
    - IPv6는 유니캐스트, 멀티캐스트 주소뿐만 아니라 새로운 주소 형태인 애니캐스트 주소가 도입되었다. 애니 캐스트 주소로 명시된 데이터그램은 호스트 그룸의 어떤 이에게든 전달될 수 있다.
- 간소화된 40 바이트 헤더
    - 40 바이트 고정 길이 헤더는 라우터가 IP 데이터그램을 더 빨리 처리하게 해준다.
    - 새로운 옵션 인코딩은 유연한 옵션 처리를 가능하게 한다.
- 흐름 레이블링
    - 정의하기 어려운 흐름을 갖고있다. RFC는 "비 디폴트 품질 서비스나 실시간 서비스 같은 특별한 처리를 요청하는 송신자에 대해 특정 흐름에 속하는 패킷 레이블링"을 가능하게 한다고 설명한다. 아직 정확한
      의미는 정의되지 않았지만, 언젠가 필요할 흐름 차별화를 예견하여 구현하였다.

<br/>

<p align="center"><img width="500" alt="IPv6 데이터그램 포맷" src="https://user-images.githubusercontent.com/76640167/212698226-9bf18f85-3111-4434-9202-f2ed45aabd28.png">

IPv6 데이터그램 포맷은 그림과 같다.

- `버전`
    - 4비트 필드는 IP 버전 번호를 인식한다. IPv6라면 6이다.
- `트래픽 클래스`
    - IPv4의 TOS 필드와 비슷한 의미로 만든 8비트 필드는 흐름 내의 SMTP 이메일 같은 애플리케이션의 데이터그램보다 Volp 같은 특정 애플리케이션 데이터그램에 우선순위를 부여하는데 사용된다.
- `흐름 레이블`
    - 데이터그램의 흐름을 인식하는데 사용된다.
- `페이로드 길이`
    - 이 16비트 값은 IPv6 데이터그램에서 고정 길이 40바이트 패킷 헤더 뒤에 나오는 바이트 길이이며, 부호 없는 정수다.
- `다음 헤더`
    - 이 필드는 데이터그램의 내용이 전달될 프로토콜을 구분한다.(TCP, UDP)
- `홉 제한`
    - 라우터가 데이터그램을 전달할 때 마다 1씩 감소하고, 0이되면 데이터그램이 라우터에 의해 버려진다.
- `출발지와 목적지 주소`
    - 출발지와 목적지 주소를 담고 있다.
- `데이터`
    - IPv6 데이터그램의 페이로드 부분이다. 데이터그램이 목적지에 도착하면 IP 데이터그램에서 페이로드를 제거한 후, 다음 헤더 필드에 명시한 프로토콜에 전달한다.

IPv4에는 있지만 IPv6에는 없는 필드

- `단편화/재결합`
    - IPv6에서는 단편화와 재결합을 출발지와 목적지만이 수행한다.
    - 라우터가 받은 IPv6 데이터그램이 너무 커서 출력 링크로 전달할 수 없다면 라우터는 데이터그램을 폐기하고 너무 크다는 ICMP 오류 메시지를 송신자에게 보낸다.
    - 송신자는 데이터를 IP 데이터그램 크기를 줄여서 다시 보낸다.
    - 라우터에서 이 기능을 수행하는 것은 시간이 오래 걸리므로 이 기능을 삭제하여 IP 전달 속도를 증가시켰다.
- `헤더 체크섬`
    - 트랜스포트 계층 프로토콜과 데이터 링크 프로토콜은 체크섬을 수행하므로 IP 설계자는 네트워크 계층의 체크섬 기능이 반복되는 것으로 생략해도 될 것이라 생각하여 삭제했다.
- `옵션`
    - IPv4에서도 잘 사용되지 않았던 필드가 사라지고 고정 헤더의 길이를 갖게되었다.
    - 다대신 옵션 필드는 IPv6 헤더에서 다음 헤더 중 하나가 될 수 있다.

<br/>

### IPv4에서 IPv6로의 전환

IPv6는 IPv4 데이터그램을 보내고 라우팅하며 받을 수 있는 새 IPv6 시스템이 있는 반면에, IPv4로 구축된 시스템은 IPv6 데이터그램을 처리할 수 없다는 것에서 발생한다.

### 플래그 데이 선언

모든 인터넷 장비를 끄고 IPv4를 IPv6로 업그레이드하는 시간과 날짜를 정하는 것으로 40년 전에 실제로 NCP를 TCP로 전이하였다.

그러나 수억개의 장비가 관련된 플레그 데이는 오늘날에는 절대 불가능하다.

<br/>

### 터널링

<p align="center"><img width="700" alt="터널링" src="https://user-images.githubusercontent.com/76640167/212711125-cbde816b-a934-4a2e-a404-92665e9e93ea.png">

실제로 널리 사용하는 방법이다.

두 IPv6 노드(그림에서는 B와 E)가 IPv6 데이터그램을 사용해서 작동한다고 가정해보자.

물론 이들은 IPv4 라우터를 통해 연결되어있다. 이렇게 IPv6 노드 사이에 연결되어있는 IPv4 라우터들을 `터널(tunnel)`이라고 한다.

IPv6 송신 과정

1. 터널의 송신 측에 있는 IPv6 노드는 IPv6 데이터그램을 받고 IPv4 데이터그램의 데이터 필드에 이것을 넣는다.
2. IPv4 데이터그램에 목적지 주소를 터널의 수신 측에 IPv6 노드로 적어서 터널의 첫 번째 노드에 보낸다.
3. 터널 내부에 있는 IPv4라우터는 IPv4 라우터는 IPv4 데이터그램이 IPv6 데이터그램을 갖고 있다는 사실을 모른채 다른 데이터그램을 처리하는 방식으로 IPv4 데이터 그램을 처리한다.
4. 터널 수신 측에 있는 IPv6 노드는 IPv4 데이터그램을 받고 이 IPv4 데이터그램이 실제 IPv6 데이터그램임을 결정한다.
5. 다음 노드에 IPv6 데이터그램을 보낸다.

기초적인 IPv6 수용은 이루어지고 있지만 최근에 이루어진 것은 없다.
