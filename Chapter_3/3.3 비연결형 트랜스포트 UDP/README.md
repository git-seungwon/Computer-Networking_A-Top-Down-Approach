# 3.3 비연결형 트랜스포트: UDP

> 💡 UDP는 트랜스포트 계층 프로토콜이 할 수 있는 최소 기능으로 동작한다.

- 다중화/역다중화 기능
- 간단한 오류 검사 기능

이외에는 IP에 아무것도 추가하지 않는다.

<br/>
<br/>

## 동작 순서

1. 애플리케이션 프로세스로부터 메시지를 가져와서  
   다중화/역다중화 서비스에 필요한 `출발지 포트 번호 필드`와 `목적지 포트 번호 필드`를 첨부한다.


2. `출발지 호스트의 IP 주소 필드`, `목적지 호스트의 IP 주소 필드`를 추가한 후에  
   최종 트랜스포트 계층 세그먼트를 네트워크 계층으로 넘겨준다.


3. 네트워크 계층은 트랜스포트 계층 세그먼트를 IP 데이터그램으로 캡슐화하고,  
   세그먼트를 수신 호스트에게 전달한다.


4. 세그먼트가 수신 호스트에 도착한다면,  
   UDP는 세그먼트의 데이터를 해당하는 애플리케이션 프로세스로 전달하기 위해 `목적지 포트 번호`를 사용한다.

<br/>

> 💡 UDP는 세그먼트를 송신하기 전에 송신 트랜스포트 계층 개체들과 수신 트랜스포트 계층 개체들 사이에 **핸드셰이크를 사용하지 않는다**.

→ `비연결형`

<br/>

### DNS

DNS는 전형적으로 UDP를 사용하는 애플리케이션 계층 프로토콜의 예이다.

만약 질의 호스트가 응답을 수신하지 못하면 질의를 다른 네임 서버로 송신하거나, 애플리케이션에게 응답을 수신할 수 없음을 통보한다.

<br/>
<br/>

## UDP의 장점

많은 애플리케이션은 다음과 같은 이유로 UDP에 더 적합하다.

<br/>

### 무슨 데이터를 언제 보낼지에 대해서 애플리케이션 레벨에서 더 정교한 제어가 가능하다

UDP 하에서 애플리케이션 프로세스가 데이터를 UDP에 **전달하자마자**  
UDP는 데이터를 UDP 세그먼트로 만들고, 그 세그먼트를 즉시 네트워크 계층으로 전달한다.

> **실시간** 애플리케이션에서는 UDP를 사용하고, **필요한 어떤 추가 기능을 구현할 수 있다.**

<br/>

↔︎ `TCP`

1. **혼잡 제어 매커니즘**이 존재한다.  
   즉, 목적지 호스트들과 출발지 호스트들 사이에서 하나 이상의 링크가 과도하게 혼잡해지면 트랜스포트 계층 TCP 송신자를 **제한**한다.


2. 신뢰적인 전달이 얼마나 오래 걸리는지에 관계없이  
   **목적지가 세그먼트의 수신 여부를 확인응답할 때까지** 데이터의 세그먼트 재전송을 계속한다.

<br/>

### 연결 설정이 없다

UDP는 TCP의 세 방향 핸드셰이크(three-way handshake)와 같은 공식적인 사전준비 없이 전송한다.

**따라서 UDP는 연결을 설정하기 위한 어떤 지연도 없다.**

<br/>

#### 연결 상태가 없다

UDP는 연결 상태를 유지하지 않으며, 연결 상태에 대한 그 어떠한 파라미터도 기록하지 않는다.

따라서 일반적으로 특정 애플리케이션 전용 서버는 애플리케이션 프로그램이 UDP에서 동작할 때  
좀 더 많은 액티브 클라이언트를 수용할 수 있다.

<br/>

#### 작은 패킷 헤더 오버헤드

TCP는 세그먼트마다 20바이트의 헤더 오버헤드를 갖지만, UDP는 단지 8바이트의 오버헤드를 갖는다.

<br/>
<br/>

## UDP의 단점

UDP는 `혼잡 제어(congestion control)`를 하지 않는다.

> 💡 `혼잡 제어`는 네트워크가 꼭 필요한 작업을 할 수 없게 되는 폭주 상태에 빠지는 것을 막기 위해 반드시 필요하다.

<br/>

만약 모두가 혼잡 제어를 사용하지 않고 높은 비트의 비디오 스트리밍을 시작한다면,

- 라우터에 많은 패킷 오버플로가 발생  
  → 소수의 UDP 패킷만이 출발지-목적지 간의 경로를 무사히 통과할 것이다.


- 제어되지 않은 UDP 송신자에 의해 발생한 높은 손실률은 그 손실률을 감소시키기 위해 TCP 송신자들이 속도를 줄이도록 할 것  
  → TCP 세션의 혼잡이 발생할 것이다.

<br/>
<br/>

## UDP를 통한 신뢰적인 데이터 전송

UDP는 비신뢰적인 서비스를 제공하지만,  
**애플리케이션 자체에서 신뢰성을 제공한다면** UDP를 사용하면서 신뢰적인 데이터 전송이 가능해진다.

<br/>

e.g., 구글의 크롬 브라우저에서 사용되는 `QUIC(Quick UDP Internet Connection) 프로토콜`

이는 기본 트랜스포트 프로토콜로 UDP를 사용하고, UDP 위에 애플리케이션 계층 프로토콜의 안정성을 구현한다.

<br/>
<br/>
<br/>

# 3.3.1 UDP 세그먼트 구조

<p align="center"><img width="270" alt="UDP 세그먼트 구조" src="https://user-images.githubusercontent.com/86337233/211334784-c3a87f6f-85ca-414b-9c72-9b40e90bb5e1.png">

<br/>

### 애플리케이션 데이터

UDP 데이터그램의 데이터 필드에 위치한다.

<br/>

### 포트 번호

목적지 호스트가 목적지 종단 시스템에서 동작하는 (역다중화 기능을 수행하는) 정확한 프로세스에게 애플리케이션 데이터를 넘기게 해준다.

<br/>

### 체크섬(checksum)

세그먼트에 오류가 발생했는지 검사하기 위해 수신 호스트가 사용한다.

<br/>

### 길이 필드

헤더를 포함하는 UDP 세그먼트의 길이를 바이트 단위로 나타낸다.

<br/>
<br/>
<br/>

# 3.3.2 UDP 체크섬

> `UDP 체크섬`은 세그먼트가 출발지로부터 목적지로 이동했을 때,  
> **UDP 세그먼트 안의 비트에 대한 변경사항이 있는지 검사**하여 오류 검출을 하기 위한 것이다.

<br/>

1. 송신자 측에서 세그먼트 안에 있는 **모든 16비트 워드의 합산에 대해 다시 1의 보수를 수행**하며,  
   합산 과정에 발생하는 오버플로는 윤회식 자리올림(wrap around)을 한다.


2. 이 결과값이 UDP 세그먼트의 체크섬 필드에 삽입된다.


3. 수신자에서는 **체크섬을 포함한 모든 16비트 워드들이 더해진다.**


4. 만약 패킷에 어떤 오류도 없다면 수신자에서의 합은 `1111111111111111`이 되며,  
   비트 중에 `0이 하나라도 있다면` 패킷에 오류가 발생했다는 것이다.

<br/>
<br/>

## UDP는 왜 체크섬을 제공하는가?

출발지와 목적지 사이의 **모든 링크가 오류 검사를 제공한다는 보장이 없기 때문이다.**

따라서 세그먼트들이 정확하게 링크를 통해 전송되었을지라도, 세그먼트가 라우터의 메모리에 저장될 때 비트 오류가 발생할 수가 있다.

<br/>

> 💡 UDP는 오류 검사를 제공하지만, **오류를 회복하기 위한 어떤 일도 하지 않는다.**

손상된 세그먼트를 그냥 버리기도 하고, 경고와 함께 손상된 세그먼트를 애플리케이션에게 넘겨주기도 한다.  
_(처리 방식은 구현에 따라서 다름)_

<br/>

---

<br/>

주어진 링크 간의 신뢰성과 메모리의 오류 검사가 보장되지도 않고, 종단 간의 데이터 전송 서비스가 오류 검사를 제공해야 한다면  
**UDP는 종단 기반으로 트랜스포트 계층에서 오류 검사를 제공해야만 한다.**

→ 이것은 `종단과 종단의 원칙(end-end principle)`의 한 예시이다.

<br/>

### 종단과 종단의 원칙(end-end principle)

하위 레벨에 있는 기능들은 상위 레벨에서 이들을 제공하는 비용과 비교했을 때 중복되거나 거의 가치가 없을 수 있다.
